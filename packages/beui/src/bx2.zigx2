const std = @import("std");

const DefaultComponentCallInfo = struct {
    called_from: std.builtin.SourceLocation,
    _internal_ui: DefaultComponentInfo,
};
const DefaultComponentInfo = struct {
    constraints: struct {},
    id: struct {},
};

const DefaultComponentResult = struct {
    size: struct {},
    rdl: struct {},
};


// transform implementation:
// 1. map '%(args) ret '
// - while rendering, when we encounter a '%{}' block, add it to a list. then when we are done with the
// fn body, do the next one in the list.

const Button = %(%: DefaultComponentCallInfo, Child: Component(DefaultComponentCallInfo, void, DefaultComponentResult)) DefaultComponentResult {
    const child_value = Child(%, {});

    const draw = %%.draw();
    draw.place(child_value.rdl, .{0, 0});
    draw.addMouseEventCapture(self.itkn.id, .{ 0, 0 }, child.size, .{ .capture_click = true });

    return .{.rdl = draw, .size = child.size};
};
const Button_compiled = struct {
    pub const __Arg0 = DefaultComponentCallInfo;
    pub const __Arg1 = Component(DefaultComponentCallInfo, void, DefaultComponentResult);
    pub const __Ret = DefaultComponentResult;
    pub fn __call(__call_info: __Arg0, Child: __Arg1) __Ret {
        const __ui = __call_info.ui(@src());

        const child_value = Child(__ui.call(@src()));

        const draw = __ui.draw();
        draw.addMouseEventCapture(self.itkn.id, .{ 0, 0 }, child.size, .{ .capture_click = true });

        return .{.rdl = draw, .size = child.size};
    }
};
const DemoUseButton = %(%: DefaultComponentCallInfo, color: Beui.Color) DefaultComponentResult {
    %struct { color: Beui.Color };

    %.* = .{.color = color};
    return %Button(%_ {
        return %Text("hello, world!", .fromHexRgb(0xFFFFFF));
    });
};
const DemoUseButton_compiled = struct {
    pub const __Arg0 = DefaultComponentCallInfo;
    pub const __Arg1 = Beui.Color;
    pub const __Ret = DefaultComponentResult;
    const __Context = struct {color: Beui.Color};
    const __Component0 = Button;
    const __Component1 = Text;
    pub fn __call(__call_info: __Arg0, color: __Arg1) __Ret {
        const __ui = __call_info.ui(@src());
        var ctx: __Context = undefined;

        ctx.* = .{.color = color};
        return __Component0.__call(__ui.call(@src()), .from(&ctx, __call_1));
    }
    pub fn __call_1(__ctx: *__Context, __call_info: __Component0.__Arg1.Arg0, _: __Component0.__Arg1.Arg1) __Component0.Arg1.Ret {
        const __ui = __call_info.ui(@src());

        return __Component1.__call("hello, world!", .fromHexRgb(0xFFFFFF));
    }
};

// if we want to remove virtual fn calls, we'd have to automatically split up functions into multiple parts
