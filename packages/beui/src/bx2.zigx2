const std = @import("std");

const ui = struct {};


fn scrollDemo2(caller: std.builtin.SourceLocation) value {
    // this works until you need context, and then it becomes annoying
    // what works well about this is we can actually compose components
    const Context = struct {};
    var ctx = Context{};

    return ui.scroller(%, %{
        scroller.child(%, %{
            return ui.textDemo(%, "hello");
        });
        scroller.child(%, %{
            return ui.textDemo(%, "world");
        });
        scroller.child(%, %{
            return ui.button(%, %{
                return ui.background(%, ui.COLOR, %{
                    return ui.text(%, "test button", .white);
                });
            });
        });
    });
    // codegen output would put all those inner ones into their own outer fns
}
fn composedDemo(caller: DefaultComponentCallInfo, child: Component(void, ChildRetTy)) void {
    const Context = struct {child: Component(void, ChildRetTy)};
    var ctx = Context{.child = child};

    return ui.button(%, %{
        return ui.background(%, ui.COLOR, %{
            return ctx.child(%);
        });
    });
}

// '%' is shorthand for @src(), _default_ui_arg
// ^ instead of @src(), we could generate a uuid based on the file's hash

const DefaultComponentCallInfo = struct {
    called_from: std.builtin.SourceLocation,
    _internal_ui: DefaultComponentInfo,
};
const DefaultComponentInfo = struct {
    constraints: struct {},
    id: struct {},
};

const DefaultComponentResult = struct {
    size: struct {},
    rdl: struct {},
};

fn button(caller: DefaultComponentCallInfo, child: Component(DefaultComponentCallInfo, void, DefaultComponentResult)) void {
    const ui = caller.ui(@src());

    const child_value = child(ui.call(@src()), {});

    const draw = ui.draw();
    draw.place(child_value.rdl, .{0, 0});
    draw.addMouseEventCapture(self.itkn.id, .{ 0, 0 }, child.size, .{ .capture_click = true });

    return .{.rdl = draw, .size = child.size};
}
const Button = struct {
    pub const Arg0 = DefaultComponentCallInfo;
    pub const Arg1 = Component(DefaultComponentCallInfo, void, DefaultComponentResult);
    pub const call = button;
};

// transform implementation:
// 1. map '%(args) ret '
// - while rendering, when we encounter a '%{}' block, add it to a list. then when we are done with the
// fn body, do the next one in the list.

const DemoUseButton = %(%: DefaultComponentCallInfo, color: Beui.Color) DefaultComponentResult {
    %struct { color: Beui.Color };

    %.* = .{.color = color};
    return %Button(%_ {
        return %Text("hello, world!", .fromHexRgb(0xFFFFFF));
    });
};
const DemoUseButton_compiled = struct {
    pub const __Arg0 = DefaultComponentCallInfo;
    pub const __Arg1 = Beui.Color;
    const __Context = struct {color: Beui.Color};
    const __Component0 = Button;
    const __Component1 = Text;
    pub fn __call(__call_info: DefaultComponentCallInfo, color: Beui.Color) DefaultComponentResult {
        const __ui = __call_info.ui(@src());
        var ctx: __Context = undefined;

        ctx.* = .{.color = color};
        return __Component0.__call(__ui.call(@src()), .from(&ctx, __call_1));
    }
    pub fn __call_1(__ctx: *__Context, __call_info: __Component0.__Arg1.Arg0, _: __Component0.__Arg1.Arg1) __Component0.Arg1.Ret {
        const __ui = __call_info.ui(@src());

        return __Component1.__call("hello, world!", .fromHexRgb(0xFFFFFF));
    }
};

// if we want to remove virtual fn calls, we'd have to automatically split up functions into multiple parts
